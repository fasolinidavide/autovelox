           .data                        #0X10010000 cella di default
IN_OUT:    .half 0	                #imposto i nostri 16 bit dell'IN_OUT a 0

           .text 			#salvo nei registri s0,s1,s2 i valori corrispondendi ai cicli che il programma deve compiere  per corrispondere alle nostre velocità
                                        #standard.
           li $s0, 6250000		#70km/h    #v=(70/3.6)m/s=19.4m/s --> t=s/v=0.05s --> VAL=(t*fck)/4= 6250000 (4 sono i passi del ciclo),
                                                   #considero le istruzioni precedenti al ciclo trascurabili, essendo troppo poche per influenzare i tempi                                           
           li $s1, 5625000		#80km/h    #v=(80/3.6)m/s=22.2m/s --> t=s/v=0.045s --> VAL=(t*fck)/4= 5625000
           li $s2, 5000000             	#90km/h    #v=(90/3.6)m/s=25m/s --> t=s/v=0.04s --> VAL=(t*fck)/4= 5000000
           
inizio:    add $s3, $zero, $zero        #setto la variabile che rappresenta il numero di cicli del passaggio della macchina a 0.

           la $s6, IN_OUT               #salvo l'indirizzo della cella IN_OUT nel registro s6
           li $s5, 268505088            #(268505088 = 0x10011000)inserisco nel registro $s5, il numero con il 12 bit a 1, la mia mask.
           
passo1:    lh $s4, 0($s6)               #controllo con il registro s4 il contenuto della cella in memoria puntata da t0, il mio IN_OUT
                                        #settare adesso (quindi solo dopo la lh precedente) il bit a 1 del sensore, 
                                        #immaginando che la macchina stia passando
           and $t1, $s4, $s5       	#controllo se la MASK e la cella hanno gli stessi bit corrispondenti, indicando il passaggio della macchina al primo sensore
           bne $t1, $s5, passo1         
	
           li $s5, 268513280            #(12288= 0x10013000)setto ad 1 il dodicesimo e il tredicesimo bit della Mask (i bit dei sensori)
           	   
passo2:    lh $s4, 0($s6)               #stesso controllo di prima anche sul secondo sensore
                                        #settare adesso il bit a 1 del sensore (senza spegnere il bit del primo sensore!)
                                        #immaginando che la macchina stia passando 
           and $t1, $s4, $s5         	#confronto Mask e cella verifico se la macchina è passata dal secondo sensore
           addi $s3, $s3, 1        	#ciclo fino a quando il confronto non si verifica, ad ogni ciclo aumento il contatore di un unità (registro s3).
           bne $t1, $s5, passo2 

           slt $t0, $s0, $s3            #verifico che il numero di cicli (il tempo) sia sia minore o maggiore rispetto a quelli a 70km/h
           bne $t0, $zero, reset  	#se vengono compiuti più cicli quindi una velocità minore, salto a reset, per poi poter tornare a controllare altre vetture

           li $t9, 125000000      	# eseguo un ciclo per passare i 0.5secondi, per evitare di dover eseguire il seguente ciclo troppe volte, 
loop:      addi $t9, $t9, -1		#si consiglia di settare manualmente il registro t9.    val=(txfck)/2=125000000
           bne $t9, $zero, loop 
  	
           slt $t0, $s1, $s3           #verifico, come prima, se il numero dei cicli, quindi il tempo di passaggio della vettura è maggiore di 80 (velocità compresa tra 70 e 80)	
           beq $t0, $zero, ricerca2    	
           li $s5, 268513538           #(268513538=0x10013102)in caso il tempo sia compreso tra 70 e 80, setto l'in_out attivando il bit in posizione 8, e attivamdo il bit in pos 1 della cella, 
           sh $s5, 0($s6) 	       #indicando lo scatto della fotocamera, salvandola prima in un registro s5 e poi copiando i bit con una sh.
           j fine                      #salto a fine

ricerca2:  slt $t0, $s2, $s3           #verifico che sia compresa tra 80 e 90, come ho fatto in precedenza
           beq $t0, $zero, ricerca3    
           li $s5, 268513794           #(268513794=0x10013202)in caso il tempo sia compreso tra 80 e 90, setto l'in_out accendendo il bit in posizione 9, e attivo il bit in pos 1 della cella, 
           sh $s5, 0($s6)              #indicando lo scatto della fotocamera, salvandola prima in un registro s5 e poi copiando i bit con una sh.
           j fine                      #jumpo a fine

ricerca3:  li $s5, 268514050           #(268514050=0x10013302)i 2 casi precedenti non sono verificati, si entra in automatico nel caso della velocità maggiore di 90 
           sh $s5, 0($s6)              
           
fine:      li $t9, 25000000            #aspettiamo 0.1 secondi, tempo di scatto della fotocamera.     val=(txfck)/2= 25000000
loop2:     addi $t9, $t9, -1
           bne $t9, $zero, loop2
           li $s5, -16                 #(-16=0x11111100), preparo una maschera per rimettere il bit 1 della cella a 0
           lh $s4, 0($s6)              #leggo e salvo in s4 i bit della cella IN_OUT
           and $t1, $s5, $s4           #rimetto il primo  bit della cella a 0 facendo una "and" tra il valore della mask e quello appena letto e salvato in s4, 
           sh $t1, 0($s6)              #così da indicare il completamento dello scatto. metto i nuovi bit (salvati a t1) nella cella IN_OUT tramite una sh
           
reset:     li $t1, 0                   #settare a 0 tutta la IN_OUT, così da poter tornare a inizio per poi leggere il tempo di una nuova vettura, 
           sh $t1, 0($s6)              #salvando in t1 il valore a 0 e poi andandolo a mettere in IN_OUT
           j inizio                    #salto a inizio, controllo la prossima vettura
